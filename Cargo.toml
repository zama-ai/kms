[workspace]
resolver = "2"

members = [
    "bc2wrap",
    "core/grpc",
    "core/service",
    "core/threshold",
    "core-client",
    "observability",
    "tools/kms-health-check",
]

# The backward-compatibility module is excluded from the workspace in order to avoid dependency
# conflicts. This is related to the fact that it needs to import the different packages (kms,
# threshold-fhe) to test with specific versions when generating the data. However, the
# workspace already has these dependencies by nature, creating a name conflict like described in
# https://github.com/rust-lang/cargo/issues/12891
# Note that it's not possible to only generate the lock file using specific features as the resolver
# builds the graph as if all features are enabled:
# https://doc.rust-lang.org/cargo/reference/resolver.html#features
exclude = ["backward-compatibility"]

[workspace.package]
authors = ["Zama"]
publish = true
edition = "2021"
license = "BSD-3-Clause-Clear"
version = "0.11.0"

[workspace.dependencies]
# AES encryption - LOW RISK: RustCrypto org, very popular (40M+ downloads), actively maintained
aes = "=0.8.4"
# AES-based PRNG for deterministic randomness - MEDIUM RISK: Individual maintainer, low popularity, custom implementation needs audit
aes-prng = "=0.2.1"
# Error handling - LOW RISK: dtolnay (very reputable), 100M+ downloads
anyhow = "=1.0.98"
# Async trait support - LOW RISK: dtolnay, widely used
async-trait = "=0.1.88"
# AWS Nitro attestation validation - MEDIUM RISK: Security-critical, low popularity, needs audit
attestation-doc-validation = { version = "=0.10.0" }
# Internal backward compatibility testing - LOW RISK: Internal Zama module
backward-compatibility = { path = "./backward-compatibility" }
# Retry with exponential backoff - LOW RISK: Popular utility
backoff = "=0.4.0"
# Base64 encoding - LOW RISK: marshallpierce, 100M+ downloads
base64 = "=0.22.1"
# Binary serialization - LOW RISK: bincode-org, 20M+ downloads
bincode = { version = "=2.0.1", features = ["serde"] }
# Internal bincode wrapper - MEDIUM RISK: Internal custom implementation
bc2wrap = { path = "./bc2wrap" }
# Byte buffer utilities - LOW RISK: tokio team, 100M+ downloads
bytes = "=1.10.1"
# Conditional compilation - LOW RISK: alexcrichton, 100M+ downloads
cfg-if = "=1.0.3"
# CLI argument parsing - LOW RISK: clap-rs team, 100M+ downloads
clap = { version = "=4.5.47", features = ["derive"] }
# Configuration management - LOW RISK: mehcode, popular
config = "=0.15.15"
# Internal observability module - LOW RISK: Internal Zama module
observability = { path = "./observability" }
# Threshold FHE implementation - LOW RISK: Internal Zama core module
threshold-fhe = { path = "./core/threshold/", default-features = false }
# Enum dispatch optimization - LOW RISK: Popular macro utility
enum_dispatch = "0.3.13"
# Async futures - LOW RISK: rust-lang team, 100M+ downloads
futures = "=0.3.31"
# Futures utilities - LOW RISK: rust-lang team
futures-util = "=0.3.31"
# Hex encoding/decoding - LOW RISK: KokaKiwi, 100M+ downloads
hex = "=0.4.3"
# HTTP types - LOW RISK: hyperium team, 100M+ downloads
http = "=1.3.1"
# Iterator utilities - LOW RISK: bluss/rust-itertools, 100M+ downloads
itertools = "=0.14.0"
# secp256k1 elliptic curve - LOW RISK: RustCrypto org, 5M+ downloads
k256 = "=0.13.4"
# Core KMS service - LOW RISK: Internal Zama core module
kms = { path = "./core/service", default-features = false }
# KMS gRPC interface - LOW RISK: Internal Zama module
kms-grpc = { path = "./core/grpc", default-features = false }
# Lazy static initialization - LOW RISK: rust-lang-nursery, 100M+ downloads
lazy_static = "=1.5.0"
# Mocking for tests - LOW RISK: asomers, popular testing tool
mockall = "=0.13.1"
# OpenTelemetry observability - LOW RISK: CNCF project, well-maintained
opentelemetry = "=0.29.1"
# Token pasting macros - LOW RISK: dtolnay, useful macro utility
paste = "=1.0"
# Protocol Buffers - LOW RISK: tokio-rs team, 10M+ downloads
prost = "=0.13.5"
# Protocol Buffers build - LOW RISK: tokio-rs team
prost-build = "=0.13.5"
# Protocol Buffers types - LOW RISK: tokio-rs team
prost-types = "=0.13.5"
# Random number generation - LOW RISK: rust-random, 100M+ downloads
rand = "=0.8.5"
# Data parallelism - LOW RISK: rayon-rs, 50M+ downloads
rayon = "=1.11.0"
# X.509 certificate generation - MEDIUM RISK: Using custom fork (see patch section), needs verification
rcgen = { version = "=0.14.0", default-features = false, features = [
    "aws_lc_rs",
    "crypto",
    "pem",
    "x509-parser",
] }
# HTTP client - LOW RISK: seanmonstar, 50M+ downloads, uses rustls for TLS
reqwest = { version = "=0.12.22", default-features = false, features = [
    "json",
    "rustls-tls",
] }
# JSON Schema generation - LOW RISK: GREsau, popular
schemars = "=0.8.22"
# Serialization framework - LOW RISK: dtolnay, 200M+ downloads, industry standard
serde = { version = "1.0.223", features = ["derive", "rc"] }
# JSON serialization - LOW RISK: dtolnay, 200M+ downloads
serde_json = "=1.0.145"
# Serial test execution - LOW RISK: palfrey, useful for testing
serial_test = "=3.2.0"
# Enum utilities - LOW RISK: Peternator7, popular enum tooling
strum = "=0.27.1"
# Enum derive macros - LOW RISK: Peternator7
strum_macros = "=0.27.1"
# Temporary file handling - LOW RISK: Stebalien, 50M+ downloads
tempfile = "=3.20.0"
# Error derive macro - LOW RISK: dtolnay, 100M+ downloads
thiserror = "=2.0.12"
# gRPC health checking - LOW RISK: hyperium team
tonic-health = "=0.13.1"
# TLS support for tonic - LOW RISK: hyperium team
tonic-tls = "=0.3.0"
# Service framework - LOW RISK: tower-rs team, 50M+ downloads
tower = "=0.5.2"
# HTTP middleware - LOW RISK: tower-rs team
tower-http = "=0.6.6"
# Fully Homomorphic Encryption library - LOW RISK: Zama (same company), core crypto
tfhe = "=1.3.3"
# Cryptographically secure PRNG for TFHE - LOW RISK: Zama
tfhe-csprng = "=0.6.0"
# TFHE versioning support - LOW RISK: Zama
tfhe-versionable = "=0.6.1"
# Zero-knowledge proofs for TFHE - LOW RISK: Zama
tfhe-zk-pok = "=0.7.2"
# Async runtime - LOW RISK: tokio team, 100M+ downloads, industry standard
tokio = { version = "=1.46.1", features = ["full"] }
# Async TLS - LOW RISK: rustls team, memory-safe TLS implementation
tokio-rustls = { version = "=0.26.2", default-features = false, features = [
    "aws_lc_rs",
] }
# gRPC framework - LOW RISK: hyperium team, 10M+ downloads
tonic = "=0.13.1"
# gRPC code generation - LOW RISK: hyperium team
tonic-build = "=0.13.1"
# Application instrumentation - LOW RISK: tokio-rs team, 100M+ downloads
tracing = { version = "=0.1.41", features = ["log"] }
# Log file rotation - LOW RISK: tokio-rs team
tracing-appender = "=0.2.3"
# OpenTelemetry integration - LOW RISK: tokio-rs team
tracing-opentelemetry = "=0.30.0"
# Tracing subscriber - LOW RISK: tokio-rs team
tracing-subscriber = { version = "=0.3.20", features = ["fmt", "std"] }
# Trait variant generation - LOW RISK: rust-lang team utility
trait-variant = "0.1.2"
# Struct validation - MEDIUM RISK: Individual maintainer, less active maintenance
validator = { version = "=0.20.0", features = ["derive"] }
# Secure memory wiping - LOW RISK: RustCrypto org, critical for key management, 10M+ downloads
zeroize = { version = "=1.8.1", features = ["zeroize_derive"] }
# X.509 certificate parsing - LOW RISK: rusticata team, 5M+ downloads
x509-parser = { version = "=0.17.0", features = ["verify"] }

# Ethereum ABI encoding - LOW RISK: Alloy/Paradigm team, reputable, growing ecosystem
alloy-dyn-abi = "=1.3.1"
# Ethereum primitives - LOW RISK: Alloy/Paradigm team
alloy-primitives = "=1.3.1"
# Solidity types & EIP-712 - LOW RISK: Alloy/Paradigm team
alloy-sol-types = "=1.3.1"
# Ethereum signing abstraction - LOW RISK: Alloy/Paradigm team
alloy-signer = "=1.0.30"
# Local Ethereum signer - LOW RISK: Alloy/Paradigm team
alloy-signer-local = "=1.0.30"

[profile.wasm]
inherits = "release"
opt-level = 'z'
lto = true
codegen-units = 1
panic = 'abort'

[profile.dev.package."*"]
# Set the default for dependencies in Development mode.
opt-level = 3

[profile.dev]
# Turn on a small amount of optimization in Development mode.
opt-level = 1
# Ensure all possible speed ups on dev compilation on Macos is enabled
split-debuginfo = "unpacked"

[profile.test]
opt-level = 3

[profile.bench]
debug = true

# actual release profile
[profile.release]
# enforce LTO to fat, which makes compilation much more expensive (time and memory), but can improve runtime performance
lto = "fat"

# profile for testing and CI
[profile.release-lto-off]
# use release profile settings
inherits = "release"
# but set LTO to the default (off instead of fat)
lto = "off"

[patch.crates-io]
# MEDIUM RISK: Using fork instead of upstream - verify changes, consider upstreaming
rcgen = { git = 'https://github.com/mkmks/rcgen.git', branch = 'k256' }
