//! Isolated versions of threshold key generation tests

use crate::client::test_tools::{setup_threshold_isolated, ThresholdTestConfig};
#[cfg(feature = "insecure")]
use crate::client::tests::threshold::common::threshold_key_gen_isolated;
use crate::util::key_setup::test_material_manager::TestMaterialManager;
use crate::util::key_setup::test_material_spec::TestMaterialSpec;
use crate::vault::storage::{file::FileStorage, StorageType};
use anyhow::Result;
use kms_grpc::kms_service::v1::core_service_endpoint_client::CoreServiceEndpointClient;
use std::collections::HashMap;
use tempfile::TempDir;
use threshold_fhe::execution::runtime::party::Role;
use tonic::transport::Channel;

#[cfg(feature = "insecure")]
use crate::engine::base::derive_request_id;
#[cfg(feature = "insecure")]
use kms_grpc::kms::v1::FheParameter;

/// Helper to setup isolated threshold test environment for key generation
async fn setup_isolated_threshold_keygen_test(
    test_name: &str,
    party_count: usize,
) -> Result<(
    TempDir,
    HashMap<u32, crate::client::test_tools::ServerHandle>,
    HashMap<u32, CoreServiceEndpointClient<Channel>>,
)> {
    let source_path = std::env::current_dir()?
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("test-material");
    let manager = TestMaterialManager::new(Some(source_path));
    let spec = TestMaterialSpec::threshold_basic(party_count);
    let material_dir = manager.setup_test_material(&spec, test_name).await?;

    let mut pub_storages = Vec::new();
    let mut priv_storages = Vec::new();
    for i in 1..=party_count {
        let role = Role::indexed_from_one(i);
        pub_storages.push(FileStorage::new(
            Some(material_dir.path()),
            StorageType::PUB,
            Some(role),
        )?);
        priv_storages.push(FileStorage::new(
            Some(material_dir.path()),
            StorageType::PRIV,
            Some(role),
        )?);
    }

    let threshold = ((party_count - 1) / 3).max(1);
    let (servers, clients) = setup_threshold_isolated(
        threshold as u8,
        pub_storages,
        priv_storages,
        (0..party_count).map(|_| None).collect(),
        ThresholdTestConfig {
            test_material_path: Some(material_dir.path()),
            ..Default::default()
        },
    )
    .await;

    Ok((material_dir, servers, clients))
}

#[tokio::test]
#[cfg(feature = "insecure")]
async fn test_insecure_dkg_isolated() -> Result<()> {
    let party_count = 4;
    let (_material_dir, servers, clients) =
        setup_isolated_threshold_keygen_test("insecure_dkg", party_count).await?;

    let key_id = derive_request_id("test_insecure_dkg_isolated")?;

    // Generate key using insecure mode
    threshold_key_gen_isolated(&clients, &key_id, FheParameter::Test).await?;

    // Verify key was generated by checking result
    for client in clients.values() {
        let mut cur_client = client.clone();
        let result = cur_client
            .get_insecure_key_gen_result(tonic::Request::new(key_id.into()))
            .await?;
        assert_eq!(result.into_inner().request_id, Some(key_id.into()));
    }

    for (_, server) in servers {
        server.assert_shutdown().await;
    }

    Ok(())
}

#[tokio::test]
#[cfg(feature = "insecure")]
async fn default_insecure_dkg_isolated() -> Result<()> {
    let party_count = 4;
    let (_material_dir, servers, clients) =
        setup_isolated_threshold_keygen_test("default_insecure_dkg", party_count).await?;

    let key_id = derive_request_id("default_insecure_dkg_isolated")?;

    // Generate key using Default parameter (larger keys)
    threshold_key_gen_isolated(&clients, &key_id, FheParameter::Default).await?;

    // Verify key was generated
    for client in clients.values() {
        let mut cur_client = client.clone();
        let result = cur_client
            .get_insecure_key_gen_result(tonic::Request::new(key_id.into()))
            .await?;
        assert_eq!(result.into_inner().request_id, Some(key_id.into()));
    }

    for (_, server) in servers {
        server.assert_shutdown().await;
    }

    Ok(())
}
