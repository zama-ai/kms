name: zama-core-threshold
# TODO: proper networking between nodes

services:
  # 1. We generate signing keys and CA certificates for all nodes
  dev-kms-core-gen-signing-keys-ca-certs:
    image: ghcr.io/zama-ai/kms/core-service:latest-dev
    build:
      context: .
      target: dev
      dockerfile: ./docker/core/service/Dockerfile
      cache_from:
        - ghcr.io/zama-ai/kms/core-service:latest-dev
      args:
        LTO_RELEASE: ${LTO_RELEASE}
        RUST_IMAGE_VERSION: ${RUST_IMAGE_VERSION}
    env_file:
      - "docker-compose-kms-core.env"
    entrypoint:
      - /bin/sh
      - -c
      - |
        AWS_ACCESS_KEY_ID=$$(cat /minio_secrets/access_key) &&
        export AWS_ACCESS_KEY_ID &&
        AWS_SECRET_ACCESS_KEY=$$(cat /minio_secrets/secret_key) &&
        export AWS_SECRET_ACCESS_KEY &&
        echo 'Starting signing key and CA certificates generation for all cores' &&
        for i in 1 2 3 4; do \
          kms-gen-keys --mock-enclave --aws-region us-east-1 \
            --public-storage s3 --public-s3-bucket kms \
            --aws-s3-endpoint http://dev-s3-mock:9000 \
            --private-storage file --private-file-path ./keys \
            --cmd signing-keys \
            threshold \
            --signing-key-party-id $$i --tls-subject dev-kms-core-$$i.com \
            --tls-wildcard && \
            wget -O ./certs/cert_dev-kms-core-$$i.com.pem ftp://$$AWS_ACCESS_KEY_ID:$$AWS_SECRET_ACCESS_KEY@dev-s3-mock:8021/kms/PUB-p$$i/CACert/60b7070add74be3827160aa635fb255eeeeb88586c4debf7ab1134ddceb4beee && \
            cat ./certs/cert_dev-kms-core-$$i.com.pem; \
        done &&
        exit 0
    volumes:
      - keys:/app/kms/core/service/keys
      - certs:/app/kms/core/service/certs
      - minio_secrets:/minio_secrets
    depends_on:
      dev-s3-mock-setup:
        condition: service_completed_successfully
  
  # 2. We start all cores
  dev-kms-core-1:
    hostname: abcd.dev-kms-core-1.com
    image: ghcr.io/zama-ai/kms/core-service:latest-dev
    build:
      context: .
      target: dev
      dockerfile: ./docker/core/service/Dockerfile
      cache_from:
        - ghcr.io/zama-ai/kms/core-service:latest-dev
      args:
        LTO_RELEASE: ${LTO_RELEASE}
        RUST_IMAGE_VERSION: ${RUST_IMAGE_VERSION}
    ports:
      - "50001:50001"
      - "50100:50100"
      - "9646:9646"
    healthcheck:
      test: "grpc_health_probe --addr=localhost:50100"
      interval: 1s
      timeout: 1s
      retries: 5
      start_period: 1s
    volumes:
      - ./core/service/config/:/app/kms/core/service/config
      - keys:/app/kms/core/service/keys
      - certs:/app/kms/core/service/certs
      - minio_secrets:/minio_secrets
      - ./lsof-mon.sh:/app/kms/core/service/lsof-mon.sh
      - ./lsof-output:/app/kms/core/service/lsof-output
    depends_on:
      dev-s3-mock-setup:
        condition: service_completed_successfully
      dev-kms-core-gen-signing-keys-ca-certs:
        condition: service_completed_successfully
    env_file:
      - "docker-compose-kms-core.env"
    environment:
      - DOCKER_BUILDKIT=1
    # We do a key-gen first because otherwise the service won't start
    # NOTE: currently debugging the upload to s3
    # Credentials are set with both credentials file and env-var
    entrypoint: >
      /bin/sh -c "
      AWS_ACCESS_KEY_ID=$$(cat /minio_secrets/access_key) &&
      export AWS_ACCESS_KEY_ID &&
      AWS_SECRET_ACCESS_KEY=$$(cat /minio_secrets/secret_key) &&
      export AWS_SECRET_ACCESS_KEY &&
      echo 'Starting kms service' &&
      bash -c \"./lsof-mon.sh lsof-output 1 &\" && sleep 1 &&
      kms-server --config-file config/compose_1.toml
      "

  dev-kms-core-2:
    hostname: abcd.dev-kms-core-2.com
    image: ghcr.io/zama-ai/kms/core-service:latest-dev
    build:
      context: .
      target: dev
      dockerfile: ./docker/core/service/Dockerfile
      cache_from:
        - ghcr.io/zama-ai/kms/core-service:latest-dev
      args:
        LTO_RELEASE: ${LTO_RELEASE}
        RUST_IMAGE_VERSION: ${RUST_IMAGE_VERSION}
    ports:
      - "50002:50002"
      - "50200:50200"
    healthcheck:
      test: "grpc_health_probe --addr=localhost:50200"
      interval: 1s
      timeout: 1s
      retries: 5
      start_period: 1s
    volumes:
      - ./core/service/config/:/app/kms/core/service/config
      - keys:/app/kms/core/service/keys
      - certs:/app/kms/core/service/certs
      - minio_secrets:/minio_secrets
      - ./lsof-mon.sh:/app/kms/core/service/lsof-mon.sh
      - ./lsof-output:/app/kms/core/service/lsof-output
    env_file:
      - "docker-compose-kms-core.env"
    environment:
      - DOCKER_BUILDKIT=1
    entrypoint: >
      /bin/sh -c "
      AWS_ACCESS_KEY_ID=$$(cat /minio_secrets/access_key) &&
      export AWS_ACCESS_KEY_ID &&
      AWS_SECRET_ACCESS_KEY=$$(cat /minio_secrets/secret_key) &&
      export AWS_SECRET_ACCESS_KEY &&
      echo 'Starting kms service' &&
      bash -c \"./lsof-mon.sh lsof-output 2 &\" && sleep 1 &&
      kms-server --config-file config/compose_2.toml
      "
    depends_on:
      dev-s3-mock-setup:
        condition: service_completed_successfully
      dev-kms-core-gen-signing-keys-ca-certs:
        condition: service_completed_successfully

  dev-kms-core-3:
    hostname: abcd.dev-kms-core-3.com
    image: ghcr.io/zama-ai/kms/core-service:latest-dev
    build:
      context: .
      target: dev
      dockerfile: ./docker/core/service/Dockerfile
      cache_from:
        - ghcr.io/zama-ai/kms/core-service:latest-dev
      args:
        LTO_RELEASE: ${LTO_RELEASE}
        RUST_IMAGE_VERSION: ${RUST_IMAGE_VERSION}
    ports:
      - "50003:50003"
      - "50300:50300"
    healthcheck:
      test: "grpc_health_probe --addr=localhost:50300"
      interval: 1s
      timeout: 1s
      retries: 5
      start_period: 1s
    volumes:
      - ./core/service/config/:/app/kms/core/service/config
      - keys:/app/kms/core/service/keys
      - certs:/app/kms/core/service/certs
      - minio_secrets:/minio_secrets
      - ./lsof-mon.sh:/app/kms/core/service/lsof-mon.sh
      - ./lsof-output:/app/kms/core/service/lsof-output
    env_file:
      - "docker-compose-kms-core.env"
    environment:
      - DOCKER_BUILDKIT=1
    entrypoint: >
      /bin/sh -c "
      AWS_ACCESS_KEY_ID=$$(cat /minio_secrets/access_key) &&
      export AWS_ACCESS_KEY_ID &&
      AWS_SECRET_ACCESS_KEY=$$(cat /minio_secrets/secret_key) &&
      export AWS_SECRET_ACCESS_KEY &&
      echo 'Starting kms service' &&
      bash -c \"./lsof-mon.sh lsof-output 3 &\" && sleep 1 &&
      kms-server --config-file config/compose_3.toml
      "
    depends_on:
      dev-s3-mock-setup:
        condition: service_completed_successfully
      dev-kms-core-gen-signing-keys-ca-certs:
        condition: service_completed_successfully

  dev-kms-core-4:
    hostname: abcd.dev-kms-core-4.com
    image: ghcr.io/zama-ai/kms/core-service:latest-dev
    build:
      context: .
      target: dev
      dockerfile: ./docker/core/service/Dockerfile
      cache_from:
        - ghcr.io/zama-ai/kms/core-service:latest-dev
      args:
        LTO_RELEASE: ${LTO_RELEASE}
        RUST_IMAGE_VERSION: ${RUST_IMAGE_VERSION}
    ports:
      - "50004:50004"
      - "50400:50400"
    healthcheck:
      test: "grpc_health_probe --addr=localhost:50400"
      interval: 1s
      timeout: 1s
      retries: 5
      start_period: 1s
    volumes:
      - ./core/service/config/:/app/kms/core/service/config
      - keys:/app/kms/core/service/keys
      - certs:/app/kms/core/service/certs
      - minio_secrets:/minio_secrets
      - ./lsof-mon.sh:/app/kms/core/service/lsof-mon.sh
      - ./lsof-output:/app/kms/core/service/lsof-output
    env_file:
      - "docker-compose-kms-core.env"
    environment:
      - DOCKER_BUILDKIT=1
    entrypoint: >
      /bin/sh -c "
      AWS_ACCESS_KEY_ID=$$(cat /minio_secrets/access_key) &&
      export AWS_ACCESS_KEY_ID &&
      AWS_SECRET_ACCESS_KEY=$$(cat /minio_secrets/secret_key) &&
      export AWS_SECRET_ACCESS_KEY &&
      echo 'Starting kms service' &&
      bash -c \"./lsof-mon.sh lsof-output 4 &\" && sleep 1 &&
      kms-server --config-file config/compose_4.toml
      "
    depends_on:
      dev-s3-mock-setup:
        condition: service_completed_successfully
      dev-kms-core-gen-signing-keys-ca-certs:
        condition: service_completed_successfully

  # 3. Initialize the different cores
  dev-kms-core-init:
    image: ghcr.io/zama-ai/kms/core-service:latest-dev
    build:
      context: .
      target: dev
      dockerfile: ./docker/core/service/Dockerfile
      cache_from:
        - ghcr.io/zama-ai/kms/core-service:latest-dev
      args:
        LTO_RELEASE: ${LTO_RELEASE}
        RUST_IMAGE_VERSION: ${RUST_IMAGE_VERSION}
    depends_on:
      dev-kms-core-1:
        condition: service_healthy
      dev-kms-core-2:
        condition: service_healthy
      dev-kms-core-3:
        condition: service_healthy
      dev-kms-core-4:
        condition: service_healthy
    env_file:
      - "docker-compose-kms-core.env"
    environment:
      - RUN_MODE=dev
    entrypoint: >
      /bin/sh -c "
      echo \"Starting initialization procedure\" &&
      kms-init -a http://abcd.dev-kms-core-1.com:50100 http://abcd.dev-kms-core-2.com:50200 http://abcd.dev-kms-core-3.com:50300 http://abcd.dev-kms-core-4.com:50400 &&
      echo \"Core services initialization done\" &&
      sleep 1 &&
      echo \"Exiting core service init...\" &&
      exit 0
      "

  debug:
    image: ubuntu:22.04
    # Keep container running
    command: tail -f /dev/null
    # For better interactive debugging
    stdin_open: true
    tty: true

volumes:
  keys:
  certs:
  minio_data:
  minio_secrets:
