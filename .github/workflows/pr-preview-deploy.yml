##############################################################################
# pr-preview workflow
##############################################################################
name: pr-preview-deploy

on:
  pull_request:
    types: [opened, labeled, synchronize, reopened]

permissions: {}

jobs:
  ############################################################################
  # Docker build pipeline
  # Triggered by:
  # - Label : "pr-preview-<deployment-type>" on pull request
  ############################################################################
  # docker-build:
  #   name: docker-build
  #   if: >-
  #     contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-threshold') ||
  #     contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-centralized') ||
  #     contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-thresholdWithEnclave') ||
  #     contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-centralizedWithEnclave')
  #   permissions:
  #     actions: read # Required to read workflow run information
  #     contents: write # Required to checkout repository code
  #     id-token: write # Required for OIDC authentication
  #     pull-requests: read # Required to read pull requests information
  #     packages: write # Required to publish Docker images
  #     attestations: write # Required to create build attestations
  #   uses: ./.github/workflows/docker-build.yml
  #   secrets:
  #     BLOCKCHAIN_ACTIONS_TOKEN: ${{ secrets.BLOCKCHAIN_ACTIONS_TOKEN }}
  #     AWS_ACCESS_KEY_S3_USER: ${{ secrets.AWS_ACCESS_KEY_S3_USER }}
  #     AWS_SECRET_KEY_S3_USER: ${{ secrets.AWS_SECRET_KEY_S3_USER }}
  #     SLAB_ACTION_TOKEN: ${{ secrets.SLAB_ACTION_TOKEN }}
  #     SLAB_BASE_URL: ${{ secrets.SLAB_BASE_URL }}
  #     JOB_SECRET: ${{ secrets.JOB_SECRET }}
  #     CGR_USERNAME: ${{ secrets.CGR_USERNAME }}
  #     CGR_PASSWORD: ${{ secrets.CGR_PASSWORD }}

  ############################################################################
  # PR Preview Job
  ############################################################################
  pr-preview-deploy:
    name: pr-preview-deploy
    if: >-
      contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-threshold') ||
      contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-centralized') ||
      contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-thresholdWithEnclave') ||
      contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-centralizedWithEnclave')
    permissions:
      pull-requests: write # Required to update pull requests information
    # needs:
    #   - docker-build
    runs-on: "runs-on=${{ github.run_id }}/runner=16cpu-linux-x64/spot=false"
    timeout-minutes: 1800

    # Environment variables used throughout the job
    env:
      NAMESPACE: 'kms-ci-${{ github.actor }}-${{ github.event.pull_request.number }}'
      TKMS_INFRA_CHART_VERSION: '0.3.2'
      SYNC_SECRETS_CHART_VERSION: '0.2.1'
      KMS_CORE_ENCLAVE_IMAGE_NAME: 'ghcr.io/zama-ai/kms/core-service-enclave'
      KMS_CORE_IMAGE_NAME: 'ghcr.io/zama-ai/kms/core-service'
      KMS_CORE_CLIENT_IMAGE_NAME: 'ghcr.io/zama-ai/kms/core-client'
      KMS_CORE_IMAGE_TAG: '0ff6b93' # ${{ needs.docker-build.outputs.image_tag }}
      KMS_CORE_CLIENT_IMAGE_TAG: '0ff6b93' # ${{ needs.docker-build.outputs.image_tag }}
      IMAGE_REPO: 'ghcr.io/zama-ai/kms'
      TLS: 'true'
      FHE_PARAMS: 'Test'
      DEPLOYMENT_TYPE: ''
    steps:
      # ======================================================================
      # DETERMINE DEPLOYMENT TYPE:
      # - pr-preview-threshold: threshold
      # - pr-preview-thresholdWithEnclave: thresholdWithEnclave
      # - pr-preview-centralized: centralized
      # - pr-preview-centralizedWithEnclave: centralizedWithEnclave
      # ======================================================================
      - name: Determine Deployment Type
        if: contains(toJSON(github.event.pull_request.labels.*.name), 'pr-preview-')
        env:
          PR_LABELS: ${{ toJSON(github.event.pull_request.labels.*.name) }}
        run: |
          echo "PR labels: $PR_LABELS"
          DEPLOYMENT_TYPE=$(echo "$PR_LABELS" | jq -r '.[] | select(startswith("pr-preview-"))' | head -n 1 | sed 's/.*-//')
          if [[ "${DEPLOYMENT_TYPE}" == *"threshold"* ]]; then
            { echo "NB_KMS_PARTIES=4"; \
              echo "THRESHOLD_VALUE=1"; \
              echo "NUM_MAJORITY=2"; \
              echo "NUM_RECONSTRUCT=3"; \
              echo "DEPLOYMENT_TYPE=${DEPLOYMENT_TYPE}"
            } >> "$GITHUB_ENV"
          elif [[ "${DEPLOYMENT_TYPE}" == *"centralized"* ]]; then
            { echo "NB_KMS_PARTIES=1"; \
              echo "NUM_MAJORITY=1"; \
              echo "NUM_RECONSTRUCT=1"; \
              echo "DEPLOYMENT_TYPE=${DEPLOYMENT_TYPE}"
            } >> "$GITHUB_ENV"
          fi
          echo "Deployment type: $DEPLOYMENT_TYPE with $NB_KMS_PARTIES KMS parties"

      # ======================================================================
      # DOCKER BUILD STATUS HANDLING
      # ======================================================================
      - name: Login to zws GitHub Container Registry
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.ZWS_BOT_TOKEN }}

      - name: Handle pre-built images
        if: ${{ env.DEPLOYMENT_TYPE == 'thresholdWithEnclave' || env.DEPLOYMENT_TYPE == 'centralizedWithEnclave' }}
        env:
          JQ_VERSION: 1.8.1
        run: |
          ###################################################################
          # USING PRE-BUILT IMAGES
          # This handles manual runs with dockerBuild=false, using provided tags
          ###################################################################
          # Download JQ.
          wget https://github.com/jqlang/jq/releases/download/jq-"${JQ_VERSION}"/jq-linux-amd64 -P /tmp

          # Install JQ.
          sudo mv /tmp/jq-linux-amd64 /usr/local/bin/jq
          sudo chmod +x /usr/local/bin/jq
          echo "JQ version: $(jq --version)"

          echo "Extracting PCR measurements for provided enclave image..."
          docker pull "${IMAGE_REPO}"/core-service-enclave:"${KMS_CORE_IMAGE_TAG}"
          PCR0=$(docker inspect "${IMAGE_REPO}"/core-service-enclave:"${KMS_CORE_IMAGE_TAG}" | jq -r '.[0].Config.Labels["zama.kms.eif_pcr0"]')
          PCR1=$(docker inspect "${IMAGE_REPO}"/core-service-enclave:"${KMS_CORE_IMAGE_TAG}" | jq -r '.[0].Config.Labels["zama.kms.eif_pcr1"]')
          PCR2=$(docker inspect "${IMAGE_REPO}"/core-service-enclave:"${KMS_CORE_IMAGE_TAG}" | jq -r '.[0].Config.Labels["zama.kms.eif_pcr2"]')
          {
            echo "PCR0=${PCR0}"
            echo "PCR1=${PCR1}"
            echo "PCR2=${PCR2}"
          } >> "$GITHUB_ENV"

      # ======================================================================
      # TOOLING SETUP
      # ======================================================================
      - name: Setup tailscale
        uses: tailscale/github-action@84a3f23bb4d843bcf4da6cf824ec1be473daf4de # v3.2.3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:kms-ci

      - name: Setup helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          export PATH=$PATH:/usr/local/bin

      - name: setup kubectl
        uses: azure/setup-kubectl@776406bce94f63e41d621b960d78ee25c8b76ede


      # ======================================================================
      # KUBERNETES & HELM SETUP
      # ======================================================================
      - name: Setup kubeconfig
        run: |
          ###################################################################
          # Configure kubeconfig to connect to the Tailscale Kubernetes cluster
          ###################################################################
          echo "Configuring kubeconfig for Tailscale cluster..."
          tailscale configure kubeconfig tailscale-operator-zws-dev.diplodocus-boa.ts.net

      # ======================================================================
      # CHECK IF NAMESPACE EXISTS
      # ======================================================================
      - name: Check if namespace exists, delete and create
        run: |
          if kubectl get namespace "${NAMESPACE}" > /dev/null 2>&1; then
            echo "Namespace ${NAMESPACE} already exists"
            echo "Destroying namespace ${NAMESPACE}..."
            helm list -n "${NAMESPACE}" --short | xargs -L1 helm uninstall -n "${NAMESPACE}"
            kubectl delete namespace "${NAMESPACE}" --grace-period=1 --timeout=5s --wait=false
            echo "Waiting for namespace to be destroyed..."
            kubectl wait --for=delete namespace/"${NAMESPACE}" --timeout=120s
            echo "Namespace ${NAMESPACE} destroyed"
            kubectl get namespace
            kubectl create namespace "${NAMESPACE}"
          else
            echo "Namespace ${NAMESPACE} does not exist"
            kubectl create namespace "${NAMESPACE}"
          fi

      - name: Checkout Project KMS
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          token: ${{ secrets.BLOCKCHAIN_ACTIONS_TOKEN }}
          persist-credentials: false


      - name: Unified Deployment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # For registry creds if needed
        run: |
          chmod +x ci/scripts/deploy_unified.sh
          ./ci/scripts/deploy_unified.sh \
            --target aws-ci \
            --namespace "${NAMESPACE}" \
            --deployment-type "${DEPLOYMENT_TYPE}" \
            --tag "${KMS_CORE_IMAGE_TAG}" \
            --num-parties "${NB_KMS_PARTIES}"

      - name: Generate PR Comment Body
        if: success()
        run: |
          if [[ "${DEPLOYMENT_TYPE}" == *"threshold"* ]]; then
            TEST_NAME="kubernetes_test_threshold"
            CONFIG_FILE="client_local_kind_threshold.toml"
            # Using a temporary file to construct multiline string for port-forward
            cat <<EOF > port_forward_cmd.txt
          kubectl port-forward svc/kms-core-1-core-1 -n ${NAMESPACE} 50100:50100 & \\
          kubectl port-forward svc/kms-core-2-core-2 -n ${NAMESPACE} 50200:50100 & \\
          kubectl port-forward svc/kms-core-3-core-3 -n ${NAMESPACE} 50300:50100 & \\
          kubectl port-forward svc/kms-core-4-core-4 -n ${NAMESPACE} 50400:50100 &
          EOF
            PORT_FORWARD_CMD=$(cat port_forward_cmd.txt)
            # Use regex to replace addresses: kms-core-X -> localhost:50X00 (e.g. party 1 -> 50100, party 2 -> 50200)
            COPY_COMMAND="kubectl cp $NAMESPACE/kms-core-client-0:/app/kms-core-client/config.toml ./core-client/config/client_local_kind_threshold.toml && \\
              sed -i '' -E 's|address = \"(http://)?kms-core-([0-9]+)-[^:]+:50100\"|address = \"http://localhost:50\200\"|' ./core-client/config/client_local_kind_threshold.toml"
          else
            TEST_NAME="kubernetes_test_centralized"
            CONFIG_FILE="client_local_kind_centralized.toml"
            # Use regex to replace address: kms-core-core -> localhost:50100
            COPY_COMMAND="kubectl cp $NAMESPACE/kms-core-client-0:/app/kms-core-client/config.toml ./core-client/config/client_local_kind_centralized.toml && \\
              sed -i '' -E 's|address = \"(http://)?kms-core-core:50100\"|address = \"http://localhost:50100\"|' ./core-client/config/client_local_kind_centralized.toml"
            PORT_FORWARD_CMD="kubectl port-forward svc/kms-core-core -n $NAMESPACE 50100:50100"
          fi

          # Generate the final comment body
          cat <<EOF > pr_comment.md
          **:rocket: Preview deployment is deployed in "${DEPLOYMENT_TYPE}" mode**

          You can now port-forward the kms-core to run your tests locally against the preview deployment.

          Connect to the Tailscale cluster zws-dev:
          \`\`\`bash
          tailscale configure kubeconfig tailscale-operator-zws-dev.diplodocus-boa.ts.net
          \`\`\`

          Port-forward the kms-core services to run your tests locally:
          \`\`\`bash
          ${PORT_FORWARD_CMD}
          \`\`\`

          Copy config.toml from core-client to ./core-client/config/${CONFIG_FILE}
          :warning: Make sure to not push this config.toml file to the repository!
          \`\`\`bash
          ${COPY_COMMAND}
          \`\`\`

           :rocket: And launch your tests:
          \`\`\`bash
          cargo nextest run --test ${TEST_NAME} --profile ci --no-fail-fast
          \`\`\`

          You can connect to the core-client with:
          \`\`\`bash
          kubectl exec kms-core-client-0 -n ${NAMESPACE} -it -- /bin/bash
          \`\`\`

          Close your port-forwarding with:
          \`\`\`bash
          pgrep -f "kubectl port-forward" | xargs -n 1 kill
          \`\`\`
          EOF

      - name: Update pull request
        if: success()
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        with:
          issue-number: ${{ github.event.pull_request.number }}
          reactions: 'rocket'
          body-path: pr_comment.md